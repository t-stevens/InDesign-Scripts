/*SET-UP*/var myDoc = app.activeDocument;var pStyles = [];var cStyles = [];var pTags = [];var cTags = [];var skipTags = [];//get style names    for (p = 0; p < myDoc.paragraphStyles.length; p++){        pStyles.push(myDoc.paragraphStyles[p].name);        }    for (c = 0; c < myDoc.characterStyles.length; c++){        cStyles.push(myDoc.characterStyles[c].name);        }//set allowed namesvar cPossible = ['skip', 'allcaps', 'dominant', 'emphasis', 'language', 'small', 'smallcaps', 'strikethrough', 'strong', 'sub', 'sup', 'underline', 'crossref', 'scriptureref', 'urlref', 'char', 'special'];var cCorrect = ['skip', 'allCaps', 'dominant', 'emphasis', 'language', 'small', 'smallCaps', 'strikethrough', 'strong', 'sub', 'sup', 'underline', 'crossRef', 'scriptureRef', 'urlRef', 'char', 'special'];var wsTags = ['br','hr','em','en','tab','RTAB','DHYPH','DBREAK','INDENT','nb'];var wsValues = ['\u000a','\u000d',' ',' ','\u0009','\','\u00ad','\​','\','\u00A0'];/*end SET-UP*/stripXML ();updateRootAttributes ();createProcessingInstruction ();createRefHeader ();updateStyles();createTags ();tagText ();applyWhitespaceTags ();combineStories ();markTableHeaders ();moveAnchors ();function stripXML(){    myDoc.xmlElements[0].xmlElements.everyItem().untag();    myDoc.deleteUnusedTags();    }function updateRootAttributes(){    var myRoot = myDoc.xmlTags[0].name;    try{        myDoc.xmlElements.item(0).xmlAttributes.add("fileID", "PD00000000_000_000");        }    catch (e){        //$.writeln ("Attribute already exists");        }    try{        myDoc.xmlElements.item(0).xmlAttributes.add("confidentiality", "public");        }    catch (e){        //$.writeln ("Attribute already exists");        }    myDoc.xmlTags.itemByName(myRoot).name = "printDocument";    }function createProcessingInstruction(){    if(myDoc.xmlInstructions.count() == 0){        var tagPI = myDoc.xmlElements.item(0).xmlInstructions.add('oxygen','RNGSchema="http://lds.org/schema/ldsxml/v4/print/ldsPrint.rng" type="xml"');        tagPI.move(LocationOptions.before, myDoc.xmlElements.item(0));        }    }function createRefHeader(){    var tagRH = myDoc.xmlTags.add("referenceHeader");    var elementRH = myDoc.xmlElements.item(0).xmlElements.add(tagRH);    elementRH.xmlAttributes.add("nextParaID", "1");    elementRH.xmlAttributes.add("versions_version.source.publishing-services.1", "2013-01-18T21:37:25.556-07:00");    elementRH.xmlAttributes.add("editor", "Transformed");    elementRH.xmlAttributes.add("approvalDate", "2016-01-01");    elementRH.xmlAttributes.add("publicationDate", "2016");    elementRH.xmlAttributes.add("description_para", "A document that is designed for the print-only schema");    elementRH.xmlAttributes.add("description_title", "Document");    elementRH.xmlAttributes.add("shortTitle", "Document");    elementRH.xmlAttributes.add("workTitle", "Document");    elementRH.xmlAttributes.add("publicationLanguage", "000");    elementRH.xmlAttributes.add("projectNumber_tracking", "PD00000000");    elementRH.move(LocationOptions.AT_BEGINNING, myDoc.xmlElements.item(0));    }function paraStylesPrefixes(){    for(i = 2; i < pStyles.length; i ++){    tempString = "";    //Confirm paragraph styles prefix    if(pStyles[i].indexOf('.') != -1){        tempA = pStyles[i].split('.');        //check if correct prefix exists        if((tempA[0].toLowerCase() == "para")||(tempA[0].toLowerCase() == "title")||(tempA[0].toLowerCase() == "skip")){            for(j = 1; j < tempA.length; j++){                tempString = tempString + tempA[j];            }            tempString = tempA[0].toLowerCase() + "." + tempString;        }        else if(tempA[0].toLowerCase() == "story"){            for(j = 1; j < tempA.length; j++){                tempString = tempString + tempA[j];            }            tempString = "Story." + tempString;        }        //add prefix if it doesn't exist        else{        	tempString = "para." + tempA.join("");	        }    }    else{        tempString = "para." + pStyles[i];    }    pStyles[i] = tempString;    }}function charStylesPrefixes(){        var flag = false;    for(i = 0; i < cStyles.length; i++){        //reset flag        flag = false;        //test styles without '.'        if(cStyles[i].indexOf ('.') == -1){            for(j = 0; j < cPossible.length; j++){                //if correct, set flag to true and move on to next style                if(cStyles[i].toLowerCase() == cPossible[j]){                    flag = true;                    break;                }            }            //if incorrect add 'char.' to beginning of style            if(flag == false){                cStyles[i] = 'char.' + cStyles[i];                }            }        //test styles with '.'        else{            tempA = cStyles[i].split('.');            for(j = 0; j < cPossible.length; j++){                //if correct, remove all other '.'s, set flag to true, and move on to next style                if(tempA[0].toLowerCase() == cPossible[j]){                    tempA[0] = tempA[0] + '.';                    cStyles[i] = tempA.join('');                    flag = true;                    break;                    }                }            //if incorrect, add 'char' and remove all other '.'s            if(flag == false){                cStyles[i] = 'char.' + tempA.join('');                }            }        }    }function formatParaStyles(){    var newStyleName;    //paragraph styles    for(i = 0; i < pStyles.length; i++){        tempA = pStyles[i].split("_");        newStyleName = tempA.join("-");        tempA = newStyleName.split(" ");        newStyleName = tempA.join("");        pStyles[i] = newStyleName;        }    //check for duplicate style names    for(i = 0; i < pStyles.length; i++){        for(j = i + 1; j < pStyles.length; j++){            if(pStyles[i] == pStyles[j]){                pStyles[j] = pStyles[j] + "-DUP" + i;                }            }        }    }function formatCharStyles(){    for(i = 0; i < cStyles.length; i++){        tempA = cStyles[i].split("_");        newStyleName = tempA.join("-");        tempA = newStyleName.split(" ");        newStyleName = tempA.join("");        cStyles[i] = newStyleName;        }    //correct capitalization    for(i = 0; i<cStyles.length; i++){        tempA = cStyles[i].split('.');        for(j = 0; j < cPossible.length; j++){            if(tempA[0].toLowerCase() == cPossible[j]) {                tempA[0] = cCorrect[j];                cStyles[i] = tempA.join('.');                }            }        }    //check for duplicate style names    for(i = 0; i < cStyles.length; i++){        for(j = i + 1; j < cStyles.length; j++){            if(cStyles[i] == cStyles[j]){                cStyles[j] = cStyles[j] + "-DUP" + i;                }            }        }}function updateStyles(){    paraStylesPrefixes ();    charStylesPrefixes ();    formatParaStyles ();    formatCharStyles ();    checkTableStyle ();    for (p = 2; p < myDoc.paragraphStyles.length; p++){        myDoc.paragraphStyles[p].name = pStyles[p];        }    for (c = 1; c < myDoc.characterStyles.length; c++){        myDoc.characterStyles[c].name = cStyles[c];        }}function createTags(){    //remove 'skip' from possible tags - paragraph styles    for(i = 0; i < pStyles.length; i++){        tempA = pStyles[i].split('.');        if(tempA[0] != 'skip'){            pTags.push(pStyles[i]);            }        else{            skipTags.push(pStyles[i]);            }        }    //remove 'skip' from possible tags - character styles    for(i = 0; i < cStyles.length; i++){        tempA = cStyles[i].split('.');        if(tempA[0] != 'skip'){            cTags.push(cStyles[i]);            }        else{            skipTags.push(cStyles[i]);            }        }    //create tags    for (i=0; i< pTags.length; i++) {        try { myDoc.xmlTags.add(pTags[i]); } catch (e) { }    }    for (i=0; i< cTags.length; i++) {        try { myDoc.xmlTags.add(cTags[i]); } catch (e) { }    }    for (i=0; i< wsTags.length; i++) {        try { myDoc.xmlTags.add(wsTags[i]); } catch (e) { }    }    try { myDoc.xmlTags.add("Story"); } catch (e) { }}function tagText(){    var tagStory = myDoc.xmlTags.add("mainStory");    myDoc.xmlElements.item(0).xmlElements.add(tagStory);    var tempName;    var tempStyle;    var tempTag;    var skips;    for(i = 2; i < pTags.length; i++){        tempName = pTags[i];        tempStyle = myDoc.paragraphStyles.itemByName(tempName);        tempTag = myDoc.xmlTags.itemByName(tempName);        myDoc.xmlExportMaps.add(tempStyle, tempTag, {includeMasterPageStories:true});        }    for(i = 1; i < cTags.length; i++){        tempName = cTags[i];        tempStyle = myDoc.characterStyles.itemByName(tempName);        tempTag = myDoc.xmlTags.itemByName(tempName);        myDoc.xmlExportMaps.add(tempStyle, tempTag, {includeMasterPageStories:true});        }    myDoc.mapStylesToXMLTags();    for(i = 1; i < myDoc.stories.length; i++){        skips = myDoc.stories[i].appliedParagraphStyle.name;        tempName = skips.split('.');        if(tempName[0] == 'skip'){            try{                myDoc.stories[i].associatedXMLElement.untag();                } catch(e){};            }        }}function applyWhitespaceTags(){    //clear find change prefernces    app.findTextPreferences = NothingEnum.nothing;    app.findChangeTextOptions.caseSensitive = false;    app.findChangeTextOptions.includeFootnotes = false;    app.findChangeTextOptions.includeHiddenLayers = false;    app.findChangeTextOptions.includeLockedLayersForFind = false;    app.findChangeTextOptions.includeLockedStoriesForFind = false;    app.findChangeTextOptions.includeMasterPages = true;    app.findChangeTextOptions.wholeWord = false;    //End clear all find/change prefernces    for(i = 0; i < wsValues.length; i++){        app.findTextPreferences.findWhat = wsValues[i];        var tempWS = myDoc.findText();        for(j=0; j<tempWS.length; j++){            try{                if(tempWS[j].associatedXMLElements[0].markupTag.name != wsTags[i]){                    try{                        mySel=tempWS[j];                        myDoc.xmlElements[0].xmlElements.add({markupTag:wsTags[i], xmlContent:mySel});                    }catch(e){}                }            }catch(e){}        }        app.findTextPreferences = NothingEnum.nothing;    }}function combineStories(){    var flag1 = 0;    var flagTag = myDoc.xmlTags.item('mainStory');    var myRoot = myDoc.xmlElements[0];    var num = myRoot.xmlElements.count();    try {        var flagName = flagTag.name;    }    catch (myError){        flag1 = 1;        var tagStory = myDoc.xmlTags.add("mainStory");    }    if(flag1 == 0){        var e1 = myRoot.xmlElements.itemByRange(2, num-1);        var ms = myRoot.xmlElements[1];    //move all stories into mainStory        try{            e1.move(LocationOptions.AT_END, ms);        }        catch(e){}        //retag 'mainStory' as 'Story' and delete 'mainStory tag        var msTag = myDoc.xmlTags.itemByName("mainStory");        msTag.remove(myDoc.xmlTags.itemByName("Story"));        }    else{        var msTag = myRoot.xmlElements[1].markupTag = tagStory;        var ms1 = myRoot.xmlElements[1];        var e1 = myRoot.xmlElements.itemByRange(2, num-1);    //move all stories into mainStory        try{            e1.move(LocationOptions.AT_END, ms1);            }        catch(e){}        //retag 'mainStory' as 'Story' and delete 'mainStory tag        var msTag = myDoc.xmlTags.itemByName("mainStory");        msTag.remove(myDoc.xmlTags.itemByName("Story"));        }}function checkTableStyle(){    var allTables = myDoc.stories.everyItem().tables.everyItem().getElements();    var tableStyle;    var t, temp, temp1;    for(i=0; i<allTables.length; i++){        t = allTables[i].storyOffset.paragraphs[0];//        $.writeln (t.appliedParagraphStyle.name);        temp = t.appliedParagraphStyle.name;        temp1 = temp.split('.');        if(temp1[0] != 'Story'){            try{                tableStyle = myDoc.paragraphStyles.item("Story.table");                tableStyleYes = tableStyle.name;                }            catch (myError){                //The style did not exist, so create it.                tableStyle = myDoc.paragraphStyles.add({name:"Story.table"});                tableStyleYes = tableStyle.name;                pStyles.push(tableStyleYes);                }            t.applyParagraphStyle(tableStyle);            }        //$.writeln (allTables[i].storyOffset.appliedParagraphStyle.name)        }    }function markTableHeaders(){    var allTables = myDoc.stories.everyItem().tables.everyItem().getElements();    var myCell;    try {        myDoc.xmlTags.add('Story.HeaderCell');         }     catch (e) { }    for(i=0; i<allTables.length; i++){        for(var j = 0; j < allTables[i].rows.length; j++){            var testRow = allTables[i].rows[j];            //$.writeln (testRow.rowType);            if(testRow.rowType == RowTypes.HEADER_ROW){                for(var k = 0; k < testRow.cells.length; k++){                    myCell = testRow.cells[k];                    myCell.associatedXMLElement.markupTag=myDoc.xmlTags.itemByName('Story.HeaderCell');                    }                }            }        }    }function moveAnchors(){    var myRoot = myDoc.xmlElements.item(0);    var anchoredStories = [];    var temp1,temp2, temp3;    try{        var allStories = myRoot.evaluateXPathExpression("//Story");        } catch(e){};    //find anchored stories    for (i=allStories.length-1; i>=0; i--){        temp1 = allStories[i].parent.markupTag.name;        temp2 = temp1.split('.');        if(temp2[0] == ('para' || 'title')){            anchoredStories.push(allStories[i]);            }        }    //move the anchored stories     for (i=anchoredStories.length-1; i>=0; i--){        anchoredStories[i].move(LocationOptions.BEFORE, anchoredStories[i].parent);        }    }